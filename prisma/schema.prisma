generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// Enums existentes
enum EstadoTransaccion {
  COMPLETADA
  PENDIENTE
  CANCELADA
}

enum TipoCategoria {
  GASTO
  INGRESO
}

enum EstadoPago {
  PENDIENTE
  PAGADO
  VENCIDO
  CANCELADO
}

enum TipoCuenta {
  EFECTIVO
  CUENTA_BANCO
  TARJETA_CREDITO
  AHORROS
  INVERSION
}

enum Frecuencia {
  NINGUNA
  DIARIA
  SEMANAL
  MENSUAL
  ANUAL
}

// Usuario principal
model User {
  id                String          @id @default(cuid())
  name              String?
  email             String?         @unique
  emailVerified     DateTime?
  password          String?
  image             String?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  currencyId        String?         // Moneda preferida del usuario

  // Relaciones de autenticación
  accounts          AuthAccount[]
  authenticators    Authenticator[]

  // Relaciones financieras
  financialAccounts FinancialAccount[] // Renombrado para evitar conflicto
  categories        Category[]
  savingsGoals      SavingsGoal[]
  reminders         PaymentReminder[]
  monthHistories    MonthHistory[]
  yearHistories     YearHistory[]
  currency          Currency?           @relation(fields: [currencyId], references: [id])
}

// Modelo de cuenta de autenticación (AuthJS)
model AuthAccount {
  id                       String  @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token           String? @db.Text
  access_token           String? @db.Text
  expires_at              Int?
  token_type              String?
  scope                   String?
  id_token               String? @db.Text
  session_state          String?
  refresh_token_expires_in Int?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts") // Mantiene el nombre de tabla original para AuthJS
}

// Resto de modelos de autenticación


model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports          String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}

// Modelos financieros
model Currency {
  id           String             @id @default(uuid())
  code         String             @unique
  name         String
  symbol       String
  users        User[]
  accounts     FinancialAccount[]
}

model FinancialAccount {
  id             String        @id @default(uuid())
  userId         String
  name           String
  type           TipoCuenta
  currencyId     String
  currentBalance Decimal       @default(0)
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  currency       Currency      @relation(fields: [currencyId], references: [id])
  transactions   Transaction[]
  transfersFrom  Transfer[]    @relation("FromAccount")
  transfersTo    Transfer[]    @relation("ToAccount")

  @@unique([userId, name])
}

model Category {
  id           String         @id @default(uuid())
  name         String
  userId       String
  type         TipoCategoria?
  icon         String?
  color        String?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions Transaction[]

  @@unique([name, userId, type])
}

model Transaction {
  id                String            @id @default(uuid())
  accountId         String
  categoryId        String
  amount           Decimal
  status           EstadoTransaccion @default(COMPLETADA)
  date             DateTime
  notes            String?
  attachments      String?
  frequency        Frecuencia?
  nextExecutionDate DateTime?
  endRecurrencyDate DateTime?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  account          FinancialAccount  @relation(fields: [accountId], references: [id])
  category         Category          @relation(fields: [categoryId], references: [id])
}

model Transfer {
  id           String           @id @default(uuid())
  fromAccountId String
  toAccountId   String
  amount       Decimal
  date         DateTime
  notes        String?
  createdAt    DateTime         @default(now())

  fromAccount  FinancialAccount @relation("FromAccount", fields: [fromAccountId], references: [id])
  toAccount    FinancialAccount @relation("ToAccount", fields: [toAccountId], references: [id])
}

model SavingsGoal {
  id            String    @id @default(uuid())
  userId        String
  name          String
  targetAmount  Decimal
  currentAmount Decimal   @default(0)
  deadline      DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PaymentReminder {
  id         String     @id @default(uuid())
  userId     String
  title      String
  amount     Decimal
  dueDate    DateTime
  frequency  Frecuencia @default(NINGUNA)
  status     EstadoPago @default(PENDIENTE)
  categoryId String?

  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model MonthHistory {
  id      Int      @id @default(autoincrement())
  userId  String
  day     Int
  month   Int
  year    Int
  income  Decimal  @db.Decimal(15,2)
  expense Decimal  @db.Decimal(15,2)

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model YearHistory {
  id      Int      @id @default(autoincrement())
  userId  String
  month   Int
  year    Int
  income  Decimal  @db.Decimal(15,2)
  expense Decimal  @db.Decimal(15,2)

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}